<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Javascript异步解决方案的发展历程]]></title>
    <url>%2Fblog%2FJavascript%2F15%2F</url>
    <content type="text"><![CDATA[1.回调函数1234567function f1(callback)&#123; setTimeout(function()&#123; //f1的任务代码 callback(); &#125;,1000);&#125;f1(f2); 123456789ajax('XXX1', () =&gt; &#123; // callback 函数体 ajax('XXX2', () =&gt; &#123; // callback 函数体 ajax('XXX3', () =&gt; &#123; // callback 函数体 &#125;) &#125;)&#125;) 优点：便于理解缺点：回调地狱，不能捕获错误 2.事件监听1234567f1.on('done', f2);function f1()&#123; setTimeout(function () &#123; // f1的任务代码 f1.trigger('done'); &#125;, 1000); &#125; 容易理解，可以绑定多个事件，每个事件可以指定多个回调函数；缺点，整个流程都要变成事件驱动型，运行流程会变得不清晰。 3.发布/订阅（观察者模式）12345678jQuery.subscribe("done", f2);function f1()&#123; setTimeout(function () &#123; // f1的任务代码 jQuery.publish("done"); &#125;, 1000);&#125;jQuery.unsubscribe("done", f2); 与”事件监听”类似，但是明显优于后者。因为我们可以通过查看”消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。 4.Promises对象Promise就是为了解决callback的问题而产生的Promise实现了链式调用，也就是说每次then后返回的都是一个全新的Promise,如果我们在 then 中 return ，return 的结果会被 Promise.resolve() 包装12345678910ajax('XXX1') .then(res =&gt; &#123; // 操作逻辑 return ajax('XXX2') &#125;).then(res =&gt; &#123; // 操作逻辑 return ajax('XXX3') &#125;).then(res =&gt; &#123; // 操作逻辑 &#125;) 解决了回调地狱的问题,无法取消 Promise ，错误需要通过回调函数来捕获 5.Generator特点：可以控制函数的执行,Generator函数是协程在ES6中的实现，最大的特点就是可以交出函数的执行权（即暂停执行）执行Generator函数后会返回一个遍历器对象（Iterator）。本质上Generator是一个状态机，每次的遍历Generator函数返回的都是函数内部的每个状态。123456789function* gen() &#123; yield 1; yield 2; return 1; &#125; var g = gen(); gen.next() // &#123;value:1,done:false&#125; gen.next() // &#123;value:2,done:false&#125; gen.next() // &#123;value:3,done:true&#125; Generator函数是分段执行的，yield语句是暂停执行的标记，而next方法可以恢复执行。缺点还需要编写自动执行器 6.使用async函数async函数的实现就是将Generator函数和自动执行器包装在一个函数中1234function async gen()&#123; awiat 1; awiat 2;&#125; 异步编程的语法目标，就是怎样让它更像同步编程，使用async/await的方法，使得异步编程与同步编程看起来相差无几了。 7.借助流程控制库NPM社区中出现了很多流程控制库可以供开发者直接使用，其中很流行的就是async库，该库提供了一些流程控制方法,其官方文档见http://caolan.github.io/async/docs.html如果需要执行的任务紧密结合。下一个任务需要上一个任务的结果做输入，应该使用瀑布式如果多个任务必须依次执行，而且之间没有数据交换，应该使用串行执行如果多个任务之间没有任何依赖，而且执行顺序没有要求，应该使用并行执行 8.使用Web WorkersWeb Worker是HTML5新标准中新添加的一个功能，Web Worker的基本原理就是在当前javascript的主线程中，使用Worker类加载一个javascript文件来开辟一个新的线程，起到互不阻塞执行的效果，并且提供主线程和新线程之间数据交换的接口：postMessage，onmessage。其数据交互过程也类似于事件发布/监听模式，异能实现异步操作 9 对比异步读取文件1.回调函数12345678fs.readFile(fileA,(err,data)=&gt;&#123; if(err) throw err; console.log(data); fs.readFile(fileB,(_err,_data)=&gt;&#123; if(_err) throw err; console.log(_data) &#125;)&#125; 2.使用Promise123456789101112131415var fs = require('fs');var readFile = function(path) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(path, (err, data) =&gt; &#123; if (err) reject(err) resolve(data) &#125;) &#125;)&#125;readFile(fileA).then((data)=&gt;&#123;console.log(data)&#125;).then(()=&gt;&#123;return readFile(fileB)&#125;).then((data)=&gt;&#123;console.log(data)&#125;)// ... 读取n次.catch((err)=&gt;&#123;console.log(err)&#125;) 3.使用Generator12345678910111213141516171819var fs = require('fs');var readFile = (path) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(path, (err, data) =&gt; &#123; if (err) reject(err) resolve(data) &#125;) &#125;)&#125;var gen = function* () &#123; var f1 = yield readFile(fileA); var f2 = yield readFile(fileB); console.log(f1.toString()); console.log(f2.toString());&#125;gen.next()grn.next() 4.使用Async123456var asyncReadFile = async function() &#123; var f1 = await readFile(fileA); var f2 = await readFile(fileB); console.log(f1.toString()) console.log(f2.toString())&#125;]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转载Javascript三座大山]]></title>
    <url>%2Fblog%2FJavascript%2F14%2F</url>
    <content type="text"><![CDATA[前端面试送命题-JS三座大山]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript中执行上下文和执行环境]]></title>
    <url>%2Fblog%2FJavascript%2F13%2F</url>
    <content type="text"><![CDATA[什么是执行上下文？js代码解析执行时所处的环境，顾名思义。 全局执行上下文只有一个，浏览器中全局对象就是window对象，this指向全局对象 函数执行上下文只有函数被调用时才会创建执行环境，可以有多个，多次。 eval执行上下文js中不推荐用这个函数 执行栈栈的结构，后进先出。先会创建一个全局的执行上下文，push到当前的执行栈顶，当调用新的函数则push新的函数执行上下文，当执行完后pop出执行栈。 执行上下文的创建过程两个阶段创建阶段和执行阶段 创建阶段确定this指向全局执行上下文中，this指向全局函数执行上下文中，this指向取决于当前调用的方式。 创建词法环境词法环境有两个组成部分环境记录是存储变量和函数声明的实际位置。对外部环境的引用意味着它可以访问其外部词法环境。 词法环境有两种类型全局环境是一个没有外部环境的词法环境，外部环境应用为null。拥有一个全局对象以及该对象拥有的对象和属性，还有用户自定义的全局变量。函数环境，包括用户在函数定义的变量存储在环境记录中，包括argumnets对象。外部环境可能是全局环境，也可能是包含内部函数的外部函数环境。 1234567891011121314151617GlobalExectionContext = &#123; // 全局执行上下文 LexicalEnvironment: &#123; // 词法环境 EnvironmentRecord: &#123; // 环境记录 Type: "Object", // 全局环境 // 标识符绑定在这里 outer: &lt;null&gt; // 对外部环境的引用 &#125; &#125;FunctionExectionContext = &#123; // 函数执行上下文 LexicalEnvironment: &#123; // 词法环境 EnvironmentRecord: &#123; // 环境记录 Type: "Declarative", // 函数环境 // 标识符绑定在这里 // 对外部环境的引用 outer: &lt;Global or outer function environment reference&gt; &#125; &#125; 创建变量环境变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性。 在 ES6 中，词法环境和变量环境的区别在于前者用于存储函数声明和变量（ let 和 const ）绑定，而后者仅用于存储变量（ var ）绑定。变量提升的原因在创建阶段，函数声明存储在环境中，而变量会被设置为 undefined（在 var 的情况下）或保持未初始化（在 let 和 const 的情况下） 执行阶段进入执行上下文添加形参，变量声明，函数声明，同一作用域下,函数提升比变量提升得更靠前. 代码执行修改变量对象的值 内存回收和内存泄露标记清除（常用）标记清除算法将“不再使用的对象”定义为“无法到达的对象”。即从根部（在JS中就是全局对象）出发定时扫描内存中的对象，凡是能从根部到达的对象，保留。那些从根部出发无法触及到的对象被标记为不再使用，稍后进行回收。ES6 新出的两种数据结构：WeakSet 和 WeakMap，表示这是弱引用，它们对于值的引用都是不计入垃圾回收机制的。 常见的内存泄露内存机制基本类型：–&gt; 栈内存（不包含闭包中的变量）引用类型：–&gt; 堆内存]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高性能Javascript读书笔记]]></title>
    <url>%2Fblog%2FJavascript%2F12%2F</url>
    <content type="text"><![CDATA[第一章 加载和执行 推荐将所有的script标签尽可能的放到body标签的底部 合并所有外链的JS 无阻塞脚本的方法 script标签的defer属性，可以让它先下载，到全部dom加载完毕后再执行 许多浏览器不支持 动态创建script dom节点 可跨域方案，利用动态插入script元素来让脚本读取、生效。123var scriptElement = document.createElement("script");scriptElement.src = "http://anydomain.com/A.js";document.getElementByTagName("head")[0].appendChild(scriptElement); XMLHttpRequest脚本注入 先创建一个XHR对象，然后用它get下载js文件，最后通过创建动态script素代码插入页面中,但是无法跨域 ，大型应用不会使用 第二章 数据存取 访问字面量和局部变量的速度最快，访问数组元素和对象成员相对较慢 访问局部变量比访问访问跨作用域变量更快，将常用的对象成员，数组元素，全局变量存储到局部变量，加快读写速度。第三章 DOM编程 dom操作天生就慢，尽量减少dom操作，减少访问dom的次数。 使用document.querySelect来做选择器，比其他方式快。 需要多次访问某个dom节点，使用局部变量存储。 尽量不要在布局信息改变时做查询。 最小化重绘和重排： 合并修改操作 使文档脱离文档流，操作，再带回文档；三种方法使dom脱离文档 隐藏元素（display: none;），操作元素，重新显示 1234var ul = document.getElementById('mylist');ul.style.display = 'none';appendDataToElement(ul, data);ul.style.display = 'block'; 文档片段(推荐，产生的DOM遍历和重排次数最少) 123var fragment = document.createDocumentFragment();appendDataToElement(fragment, data);document.getElementById('mylist').appendChild(fragment); 为修改的节点创建一个备份 1234var old = document.getElementById('mylist');var clone = old.cloneNode(true);appendDataToElement(clone, data);old.parentNode.replaceChild(clone, old); 使用事件委托来减少事件处理器的数量 第四章 算法和流程控制 倒序循环 减少对象成员和数组项的查找次数 1for(var i=0,len = items.length;i&lt;len;i++)&#123;&#125; 递归中容易出现栈溢出的情况，需要了解一下尾递归 第五章 正则表达式和字符串 字符串合并的时候简单的”+”和“+=”操作符 str+=’abc’+’efg;//2个以上的字符串拼接，会产生临时字符串 str=str+’abc’+’efg’;//推荐，提速10%~40% 关于正则还有一堆东西，以后在叙。后记，这本书之后的东西比如快速响应的用户界面，AJAX,编程实践等等感觉说的不够实在，在这里不想在叙述。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端视频资源收集]]></title>
    <url>%2Fblog%2Fresource%2F11%2F</url>
    <content type="text"><![CDATA[只分享些要钱的Vue源码解读 链接：https://pan.baidu.com/s/1yLmaYiZOm03DeUsvo8qKTw 密码：cxu5 js设计模式解读 链接：https://pan.baidu.com/s/1Be-II3JSRk5S8Xza92bHNg 密码：sihn jq源码解读 链接：https://pan.baidu.com/s/1L6-sva9p85CYfrN2ZLoaNw 密码：ba3g 小程序汇总 链接：https://pan.baidu.com/s/1wJtqc1lrHLDQbYRPFmlpxw 密码：rxic V8引擎 链接：https://pan.baidu.com/s/1hpoZoxaUmu2MWEGMplgxFw 密码：oc3d 前端面试 链接：https://pan.baidu.com/s/1dL3-bCons6uCGm1loICWCw 密码：qk34 开课吧 链接：https://pan.baidu.com/s/181f9bBkUIDXomRGv5UYUyg 密码：xz88链接：https://pan.baidu.com/s/1W9x8JRhM8hBksBTcnmq5gg 密码：0e9d]]></content>
      <categories>
        <category>resource</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>资源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序架构原理调研]]></title>
    <url>%2Fblog%2Fxcx%2F9%2F</url>
    <content type="text"><![CDATA[为什么小程序比较快？安装包缓存分包加载双线程webview预加载native组件 什么是wxs? https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxs/ 与 WXML 是在同一个线程运行的，避免了跨线程通信的开销 双线程 逻辑层：创建一个单独的线程去执行 JavaScript，在这个环境下执行的都是有关小程序业务逻辑的代码 渲染层：界面渲染相关的任务全都在 WebView 线程里执行，通过逻辑层代码去控制渲染哪些界面。一个小程序存在多个界面，所以渲染层存在多个 WebView 线程 双线程通信 在渲染层把 WXML 转化成对应的 JS 对象。 在逻辑层发生数据变更的时候，通过宿主环境提供的 setData 方法把数据从逻辑层传递到 Native，再转发到渲染层。 经过对比前后差异，把差异应用在原来的 DOM 树上，更新界面。 优点：不会阻塞，可以有多个webview,页面切换更流畅 缺点： 在 page-frame 上无法调用业务 JS。 跨线程通信的成本很高，不适合需要频繁通信的场景。 业务 JS 无法直接控制 DOM。 所以引入了wxs 运行机制冷启动 热启动更新机制 冷启动时如果发现有新版本，将会异步下载新版本的代码包，并同时用客户端本地的包进行启动，即新版本的小程序需要等下一次冷启动才会应用上。 如果需要马上应用最新版本，可以使用 wx.getUpdateManager API 进行处理。 运行机制 小程序没有重启的概念 当小程序进入后台，客户端会维持一段时间的运行状态，超过一定时间后（目前是5分钟）会被微信主动销毁 当短时间内（5s）连续收到两次以上收到系统内存告警，会进行小程序的销毁 view wcc index.wxml wcsc index.wxss component 使用Polymer框架实现Web Component Native Component 目前Native实现的组件有canvas video map textarea;Native组件层在WebView层之上 webview预加载每次小程序进入除了当前页面,Native预先额外加载一个WebView当打开指定页面时，用默认数据直接渲染，请求数据回来时局部更新返回显示历史View退出小程序，View状态不销毁 逻辑层数据绑定 Binding 单向数据流 识别哪个UI元素被绑定了相应的对象。 监视对象状态的变化。 将所有变化传播到绑定的视图上。 生命周期 Life Cycle 渲染层和逻辑层之间通信，是通过 Native 转发实现的。逻辑层通过 Page 实例的setData方法传递数据到渲染层。由于需要两个线程的一些通信消耗，为了提高性能，每次只设置需要改变的最小单位数据。生命周期顺序：onLoad -&gt; onShow -&gt; onReady。 API通过WeixinJSBridge和Native 进行通信 路由 Router小程序优点 提前新建WebView，准备新页面渲染。 View层和逻辑层分离，通过数据驱动，不直接操作DOM。 使用Virtual DOM，进行局部更新。 全部使用https，确保传输中安全。 加入rpx单位，隔离设备尺寸，方便开发。 优化分包加载 https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages.html setData原理 setData函数用于将数据从逻辑层发送到视图层（异步），同时改变对应的this.data的值（同步）。逻辑层需要更改界面时，只要把修改后的 data 通过 setData 传到渲染层。传输的数据，会转换为字符串形式传递，故应尽量避免传递大量数据。渲染层会根据前面提到的渲染机制重新生成 VD（虚拟 DOM）树，并更新到对应的 DOM 树上，引起界面变化。 一次交互，通过setDATA引起页面变化，要进过4次通信，强交互的场景会出现卡顿，所以引入原生组件 渲染层 -&gt; Native（点击事件）。Native -&gt; 逻辑层（点击事件）。逻辑层 -&gt; Native（setData）。Native -&gt; 渲染层（setData）。 数据预加载 先App中请求数据,在index.js使用数据 安全与管控 客户端系统有 JavaScript 的解释引擎，则可以创建一个单独的线程去执行 JavaScript，这个环境下只执行有关小程序业务逻辑的代码。界面渲染相关的任务呢，就丢到 webview 线程里面，通过逻辑层代码去控制渲染哪些界面。 把开发者的 JS 逻辑代码放到单独的线程去运行，因为不在 Webview 线程里，所以这个环境没有 Webview 任何接口，自然的开发者就没法直接操作 DOM，也就没法动态去更改界面或者抓取页面数据。 同时小程序不支持动态载入脚本，XSS 漏洞自然也无缝可钻 官方审核 每个微信小程序需要事先设置一个通讯域名，小程序只可以跟指定的域名与进行网络通信 须使用 HTTPS 发起网络请求。请求时系统会对服务器域名使用的 HTTPS 证书进行校验，如果校验失败，则请求不能成功发起。 token机制避免CSRF 在小程序中调用wx.login()，能拿到一个code作为用户登录凭证（有效期五分钟）。在开发者服务器后台，开发者可使用code换取openid和session_key等信息（code只能使用一次）]]></content>
      <categories>
        <category>xcx</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一点两点三四点]]></title>
    <url>%2Fblog%2Fsecret%2F10%2F</url>
    <content type="text"><![CDATA[几点实习期间的感悟1.当对技术熟悉的情况下，拿到原型图先想好自己的页面，准备切哪些图，该怎么写，用什么插件，怎么布局之类。但是如果技术不熟悉，就先上手开始写。2.css样式文件不能太复杂，能提出的公有样式尽量提出来。同类样式可以提出来一个新的文件，进行引入，相同的样式写一遍，只修改不同部分，颜色之类的公有样式提出一个新的文件夹，对之前的代码有优化的想法，请立即重构。3.尽量避免前景图，多用背景图，多采用flex布局。4.不耻下问，学无止境界]]></content>
      <categories>
        <category>secret</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从从输入URL到页面加载经历了什么（更新中）]]></title>
    <url>%2Fblog%2FInternet%2F8%2F</url>
    <content type="text"><![CDATA[1.DNS解析网址转为IP地址，是一个递归查询的过程 url:统一资源定位符 scheme://host.domain:port/path/filename DNS协议通过域名查找IP地址，域名解析就是在DNS记录一条信息记录DNS优化：DNS缓存（多级缓存）* 浏览器缓存，操作系统缓存，路由缓存。2.TCP连接TCP三次握手客户端=&gt;服务端 ：我要发送请求了服务端=&gt;客户端：我准备好了，发吧客户端=&gt;服务端：（握手结束），我马上发了，准备接受“三次握手”的目的：为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。3.发送http请求请求报文由三部分组成：请求行，请求报头和请求正文请求行： 请求方法、URL、协议版本Method Request-URL HTTP-Version CRLFeg: GET index.html HTTP/1.1 请求报头： Accept:可以处理的文件类型User-Agent:浏览器版本和操作系统Accept-Encoding:可以处理的压缩，编码格式：gizpHost:主机Cache-ControlConnection:keep-alive长连接，一个连接可以发多个请求(HTTP/1.1增加的)Cookie//post请求时Referer:访问的来源网址，跟踪来访者的来源和记录content-length: 请求正文：当使用POST, PUT等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中4.服务器处理请求并返回http报文MVC 后台处理阶段首先浏览器发送过来的请求先经过控制器，控制器进行逻辑处理和请求分发，接着会调用模型，这一阶段模型会获取 redis db 以及 MySQL 的数据，获取数据后将渲染好的页面，响应信息会以响应报文的形式返回给客户端，最后浏览器通过渲染引擎将网页呈现在用户面前。响应报文由三部分组成：响应行，响应报头和响应报文响应行：协议版本，状态码，状态码描述响应报头 server:服务器版本DateContent-type:请求类型(text/html,image/gif)Transfer-Encoding: chuncked ： 分块传输Connection：keep-aliveCache-control: private //会使用缓存Expires:缓存过期时间Content-Encoding: gizp //图片资源一般不会压缩X-UA-Compatible:浏览器兼容字段Content-lengthKeep-alive: timeout =5 , max =100 响应报文HTML，css，js，图片5.浏览器解析渲染页面dom树dom树解析：深度优先遍历，若遇到 script 标签，则 DOM 树的构建会暂停，直至脚本执行完毕。css规则树解析 CSS 规则树时 js 执行将暂停，直至 CSS 规则树就绪。浏览器在 CSS 规则树生成之前不会进行渲染。渲染树（重排和重绘）根据渲染树计算每一个节点信息绘制页面js解析：一个主线程+一个任务队列6.断开连接TCP四次握手 第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧 第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧 第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧 第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧]]></content>
      <categories>
        <category>Internet</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>笔记</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript中事件处理程序]]></title>
    <url>%2Fblog%2FJavascript%2F7%2F</url>
    <content type="text"><![CDATA[1、在DOM中，直接用onXXX=”fun();”进行绑定（HTML中直接绑定）1&lt;button id = &quot;btn&quot; onclick =&quot;fun()&quot;&gt;事件绑定&lt;/button&gt; 事件处理程序var fun = function(){……..}；移除事件处理程序fun = function(){} 优点：简单方便缺点：js和html耦合度太高，每次修改函数要变动两个地方。存在一个时差问题，用户可能会在HTML元素一出现就触发事件，但是事件处理程序没有加载好 2、在Javascript代码中用 DOM对象.onXXX=fun 进行绑定（通过js指定事件处理程序） document.getElementById(“btn”).onclick = fun;//此处绑定的是函数名移除事件处理程序document.getElementById(‘btn’).onclick = null; 优点：简单方便，有跨浏览器优势缺点：存在时差问题3、用 DOM对象.attachEvent(“onXXX”,fun) 进行绑定(IE事件处理程序) var a = document.getElementById(“btn”)a.attachEvent(“onclick”, fun);// 移除句柄a.detachEvent(‘onclick’, fun);接受两个参数，一个事件处理程序名称，一个事件处理函数匿名函数能被移除，参数必须相同） 优点：可以给一个元素添加多个事件处理程序，所有事件都会被添加到冒泡阶段，事件执行顺序逆序执行4、DOM2级事件处理程序 var a = document.getElementById(‘btn’);a.addEventListener(‘click’,function(){ });// event: 事件名称// function: 事件函数// boolean: false | true, true 为事件捕获, false 为事件冒泡(默认);Ele.addEventListener(event,function[,boolean]); // 添加句柄Ele.removeEventListener(event,function[,boolean]); // 移除句柄（匿名函数能被移除，参数必须相同） 优点：可以给一个添加多个事件处理程序，事件执行顺序顺序执行5、跨浏览器事件处理程序如果我们既要支持IE的事件处理方法，又要支持 DOM 2级事件，那么就要封装一个跨浏览器的事件处理函数，如果支持 DOM 2级事件，就用addEventListener，否则就用attachEvent。例子如下123456789101112131415161718192021222324252627282930//跨浏览器事件处理程序var eventUtil = &#123; // 添加句柄 addHandler: function(element, type, handler)&#123; if(element.addEventListener)&#123; element.addEventListener(type, handler, false); &#125;else if(element.attachEvent)&#123; element.attachEvent('on' + type, handler); &#125;else&#123; element['on' + type] = handler; &#125; &#125;, // 删除句柄 removeHandler: function(element, type, handler)&#123; if(element.removeEventListener)&#123; element.removeEventListener(type, handler, false); &#125;else if(element.detachEvent)&#123; element.detachEvent('on' + type, handler); &#125;else&#123; element['on' + type] = null; &#125; &#125;&#125;;var oBtn = document.getElementById('btn');function evtFn()&#123; alert('hello world');&#125;eventUtil.addHandler(oBtn, 'click', evtFn);eventUtil.removeHandler(oBtn, 'click', evtFn);]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>面试</tag>
        <tag>Javascript高级程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript运算符优先级和结合性]]></title>
    <url>%2Fblog%2FJavascript%2F6%2F</url>
    <content type="text"><![CDATA[先放上mdn上关于运算符优先级关联性的汇总表下面的表将所有运算符按照优先级的不同从高到低排列。 有一道题（摘自你不知道的JS(中卷））123456var a =42;var b = "foo";var c = false;var d = a &amp;&amp; b || c ? c || b ? a : c &amp;&amp; b : a;d; //42 通过查询表格，我们可以把上面代码分解： var d = ((a &amp;&amp; b) || c ) ? (( c || b ) ? a :(c &amp;&amp; b)) : a | 6 | [逻辑与] | 从左到右 | … &amp;&amp; … || 5 | [逻辑或] | 从左到右 | … || … || 4 | [条件运算符] | 从右到左 | … ? … : … | 逐一执行 (a &amp;&amp; b) 结果为：’’foo”“foo” || c 结果为 ：”foo”第一个？中，”foo”为真值(c || b)结果为：”foo”第二个？中，”foo”为真值a的值为42最后结果为42 还有一道题（摘自segmentfault）1234567891011121314151617181920212223242526function Foo() &#123; getName = function () &#123; alert(1); &#125;; return this;&#125;Foo.getName = function () &#123; alert(2);&#125;;Foo.prototype.getName = function () &#123; alert(3);&#125;;var getName = function () &#123; alert(4);&#125;;function getName() &#123; alert(5);&#125;Foo.getName(); //2getName(); //4Foo().getName(); //1getName(); //1new Foo.getName(); //2new Foo().getName(); //3new new Foo().getName(); //3 执行Foo.getName()这个函数，输出2先执行function getName(),在执行var getName = function，输出4，进行了一次覆盖执行Foo()里的getName(),因为没有用var定义，所以该函数是定义在全局的，this也指向windows,此时覆盖掉以前的4，输出1执行全局的getName, 输出1new (Foo.getName)（) .操作符优先级高于new(不带参数)优先级，输出2(new Foo()).getName(); 如果是new (Foo().getName)()，那么在执行Foo()时，它是一个函数调用，优先级低于带参数的new，因此这样不行。那么只能是(new Foo()).getName()，输出3new((new Foo()).getName)（),输出3 考察对this、原型链、函数对象、函数声明提前等一系列知识。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>面试</tag>
        <tag>玄学</tag>
        <tag>笔记</tag>
        <tag>你不知道的js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVG和Canvas]]></title>
    <url>%2Fblog%2FJavascript%2F5%2F</url>
    <content type="text"><![CDATA[Canvs和SVG都是前端绘图技术 SVG 指可缩放矢量图形，是用于描述二维矢量图形的一种图形格式，是由万维网联盟制定的开发标准。SVG使用XML格式来定义图形。这意味着SVG DOM中的每个元素都是可用的. 所以可以为每个元素附加JavaScript事件处理器在SVG中, 每个被绘制的图像均被视为对象. 如果SVG对象的属性发生变化, 那么浏览器能够自动重现图像 Canvas 一个容器Canvas通过js来绘制2D图形Canvas是逐像素进行渲染的在Canvas中, 一旦图形被绘制完成, 它就不会继续得到浏览器的关注. 如果其位置发生变化, 那么整个场景也需要重新绘制, 包括任何或许已被图形覆盖的对象. 区别 Canvas支持分辨率, SVG不支持Canvas不支持事件处理器, SVG支持Canvas只有弱的文本渲染能力, 而SVG最适合带有大型渲染区域的应用程序(比如谷歌地图)Canvas能够以.png或.jpg格式保存结果图像SVG的复杂度过高的话会减慢渲染速度(任何过度使用DOM的应用都不快)Canvas最适合图像密集型的游戏, 其中的许多对象会被频繁重绘. 而SVG不适合游戏应用Canvas是基于位图的图像,它不能够改变大小, 只能缩放显示; SVG是基于矢量的, 所以它能够很好地处理图形大小的改变 Canvas提供的功能更原始, 适合像素处理, 动态渲染和大数据量绘制; SVG功能更完善, 适合静态图片显示, 高保真文档查看和打印的应用场景绘制Canvas对象后, 不能使用脚本和CSS对它进行修改; 而SVG对象是文档对象模型的一部分, 所以可以随时使用脚本和CSS修改它们 位图和矢量图的优缺点 位图与分辨率无关，缩放后不会失真；位图放大会产生马赛克。位图色彩表现能力丰富；矢量图色彩简单。位图大；矢量图小。矢量图可以轻松转为位图，位图不能轻易转为矢量图。 绘图时交互过多选svg,绘图效率高选canvas。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>D3.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript字符串方法总结]]></title>
    <url>%2Fblog%2FJavascript%2F4%2F</url>
    <content type="text"><![CDATA[字符方法 string.chartAt()srting.chartCodeAt() 字符串操作方法 srting.concat()string.slice()string.substr()//第二个参数指定的是返回的个数//会把第二参数的负值转换为0string.substring()//都对原字符串没有影响//会把所有负值参数转换为0 字符串位置方法 string.indexOf()string.lastIndexOf() trim()方法 string.trim()//删除前后空格 大小写转换方法 string.toLowerCase()string.toUpperCase() 匹配方法 string.match()string.search()string.replace()string.slice() 其他方法 localeCompare()//比较字符串fromCharCode()//字符编码转为字符串 ES6新方法 string.includes()string.startsWith()string.endsWith()//前三个只接受字符串，不接受正则表达式，可以用indexOf()string.repeat()]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>笔记</tag>
        <tag>Javascript高级程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript数组方法总结]]></title>
    <url>%2Fblog%2FJavascript%2F3%2F</url>
    <content type="text"><![CDATA[检测数组 array.isArray() 转换方法 array.toString()array.valueOf()array.join()//join使用不同的分隔符来构建字符串//若不给join传入任何值，或者给它传入undefined，则使用逗号作为分隔符 栈方法 array.push(“a”)array.pop()//调用pop()时，它会返回数组的最后一项 队列方法 array.shift()//调用shift()时，它会返回数组的第一项array.unshift(“b”) 重排序方法 array.reverse()array.sort()//sort方法比较的是字符串//通过比较函数的返回值正负来影响排序结果1234function compare(value1, value2) &#123; return value2-value1;&#125;array.sort(compare) 操作方法 array.concat()//不影响原来数组array.slice()//不影响原来数组array.splice()//删除（0,2）//插入（2，0，’a’）//替换（2，1，’a’) 位置方法 array.indexOf()array.lastIndexOf() 迭代方法 array.every()array.some()array.foreach()array.map()array.filter()//接受一个函数function（item,index,array） 归并方法 array.reduce()array.reduceRight()//这两个方法都会迭代数组所有项//接受一个函数function（prev,cur,index,array） ES6新方法 array.find()array.findIndex()//接受一个回调函数，find()返回查找到的值，findIndex()返回索引array.fill()//接受三个参数: fill(填充值，[ , ) )array.copyWithin()//接受两个参数：粘贴索引值，复制索引值]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>笔记</tag>
        <tag>Javascript高级程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[神奇的Javascript]]></title>
    <url>%2Fblog%2FJavascript%2F2%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&gt;typeof NaN&lt;"number"//not a number,但它是number type的,NaN 的检测 isNaN。&gt;9999999999999999&lt;10000000000000000//js整数精度15位&gt;0.5 + 0.1 == 0.6&lt;true//小数精度17位&gt;0.1 + 0.2 == 0.3&lt;false//0.1+0.2值为0.30000000000000004.永远不要测定某个特点的浮点数值//可以通过乘以10或除以10来计算: 0.3&gt;Math.max()&lt;-Infinity// max 是 Math 的静态方法,返回给定的一组数字中的最大值。// 如果没有参数，结果为[`-bInfinity`]// 如果给定的参数中至少有一个参数无法被转换成数字，则会返回 [`NaN`]&gt;Math.min()&lt;Infinity// min 是 Math 的静态方法,返回给定的一组数字中的最大值。// 如果没有参数，结果为[`Infinity`]// 如果给定的参数中至少有一个参数无法被转换成数字，则会返回 [`NaN`]&gt;[] + []&lt;""//+中空数组转为空字符串，//在-，*运算中[]被转化为0&gt;[] + &#123;&#125;&lt;"[object object]"&gt;&#123;&#125; + []&lt;0&gt;true + true + true === 3&lt;true&gt;true - true&lt;0&gt;true == 1&lt;true&gt;true === 1&gt;false&gt;(!+[]+[]+![]).length&lt;9//我也看不懂，js是门玄学&gt;9+"1"&lt;"91"&gt;91-"1"&lt;90&gt;[] == 0&lt;true 在JavaScript中,加法的规则其实很简单,只有两种情况:你只能把数字和数字相加,或者字符串和字符串相加,所有其他类型的值都会被自动转换成这两种类型的值. 参考文章:https://segmentfault.com/a/1190000008038678参考文章:https://github.com/jawil/blog/issues/1原文链接:yinzhuo.online]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>玄学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道题]]></title>
    <url>%2Fblog%2FJavascript%2F1%2F</url>
    <content type="text"><![CDATA[12345var a = &#123;n : 1&#125;; var b = a; a.x =a = &#123;n : 2&#125;; console.log(a.x); // undefinedconsole.log(b.x); // &#123; n:2 &#125; 解析JS引用类型指针的工作方式&emsp;&emsp;首先是a指向了一个对象｛n:1｝,b指向了a所指向的对象&emsp;&emsp;然后 a.x = a = { n:2 }&emsp;&emsp;js赋值运算顺序为从右往左，不过由于”.”运算符优先级最高，所以先计算a.x。此时a指向的对象｛n:1 }新增了新的属性x,这个x的值为undefined。&emsp;&emsp;接着执行赋值预算 a={n:2},这个时候a指向的对象就发生了变化，指向了新的对象 ｛n:2｝。&emsp;&emsp;继续执行 a.x = a。此时啊a.x已经指向了对象｛n:1,x=undefined}中的x,等待被赋值，那么这个对象就变成了｛n:1,x:{n:2}｝,也就是b所指向的对象。 本质在于 .运算优先于=赋值运算如果还是理解不了，可以看图 其实这种题也只能拿来做考题，正常也不会有人这么写代码，写出来怕自己也理解不了。更多的写法是分开写会好一些。譬如：12345678910111213141516var a=&#123;n:1&#125;;var b=&#123;n:2&#125;;var c=a;var d;b.x=d=a.x=a=&#123;n:3&#125;//等价于a.x=&#123;n:3&#125;;b.x=&#123;n:3&#125;;a=&#123;n:3&#125;;d=&#123;n:3&#125;//结果是a : &#123;n:3&#125;b : &#123;n:2,x:&#123;n:3&#125;&#125;c : &#123;n:1,x:&#123;n:3&#125;&#125;d : &#123;n:3&#125;]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>面试</tag>
      </tags>
  </entry>
</search>
